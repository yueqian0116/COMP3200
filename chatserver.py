from socket import *
from threading import Lock, Thread, current_thread
from time import sleep
from sys import argv,exit
from server_support import *

# Shared resource (counter to count the number of data packets received)
counter = 0
counter_lock = Lock()

BUFSIZE=1024

# if you do the check on the server side and tell the client the result of the check. 
# we have to find a way to keep track of all the usernames in a channel, and make sure it does not exceed the channel capacity
# can use dictionary to keep track of channels and usernames

def handle_client(client_socket, client_address, channels, name):
    global counter
    host,_ = getnameinfo(client_address, 0)
    with client_socket:
        username = client_socket.recv(BUFSIZE).decode()
        
        if username in channels[name]["users"] or \
        username in channels[name]["queue"]:
            msg = f"[Server Message] Channel \"{name}\" already "\
            f"has user {username}."
            client_socket.sendall(msg.encode())
            return

        if not capacity_reached(channels, name):
            # channels[name]["users"].append(username)
            # channels[name]["sockets"][username] = client_socket
            add_user_to_users(username, channels, name, client_socket)
            message = f"[Server Message] You have joined the channel \"{name}\".\n"
        else:
            # channels[name]["queue"].append(username) 
            # users_in_front = len(channels[name]["queue"]) - 1 
            add_users_to_queue(username, channels, name, client_socket)
            message = f"[Server Message] You are in the waiting queue "\
                        f"and there are {users_in_front} user(s) ahead of you.\n"
        print(f"[Server Message] {username} has joined the channel \"{name}\".")
        sys.stdout.flush()
        client_socket.sendall(message.encode())

        try:
            while data := client_socket.recv(BUFSIZE):
                # Locking the shared resource (counter)
                with counter_lock:
                    # print(f"Thread {current_thread().name} got the lock.")
                    counter += 1
                    # print(f"Counter value updated to: {counter}")
                    # Simulate doing some work
                    # sleep(2)
                    message = data.decode()
                    process_message(message, client_socket, channels, username, name)
        except(ConnectionResetError, ConnectionAbortedError, OSError):
            pass

        finally: 
             # cleanup
            if username in channels[name]["users"]:
                channels[name]["users"].remove(username)

            if username in channels[name]["sockets"]:
                channels[name]["sockets"].pop(username)
            # How to notify to all other clients? [Server Message] client_username has left the channel. 
        # error or EOF - client disconnected



def start_server(port, name, channel):
    listening_socket = socket(AF_INET, SOCK_STREAM)
    listening_socket.bind(('', port))
    listening_socket.listen(5)

    return listening_socket

def process_connections(listening_socket, channels, name):
    while True:
        client_socket, client_address = listening_socket.accept()
        client_thread = Thread(target=handle_client, 
                args=(client_socket, client_address, channels, name))
        client_thread.start()


# CHATGPT
""""
handle_stdin()
---------------------
Function enables processing of commands in chatserver's stdin
REF: This function was generated by ChatGPT (to only get the template and How I should start)
REF: Function was then highly modified to work with my other functions,
"""
def handle_stdin(channels):
    while True:
        try:
            line = stdin.readline()
            if not line:
                continue
            line = line.strip()
            if not line.startswith('/'):
                continue

            tokens = line.split()
            if not tokens:
                continue
            
            cmd = tokens[0]
            args = tokens[1:]

            # /kick
            if cmd == "/kick":
                if len(args) != 2:
                    print("Usage: /kick channel_name client_username")
                    sys.stdout.flush()
                channel = args[0]
                username = args[1]
                if channel not in channels:
                    print(f"[Server Message] Channel \"{channel}\" does not exist. ")
                elif username not in channels[channel]["users"]:
                    print(f"[Server Message] {username} is not in the channel. ")

                # channel and username exists, Kick user
                client_socket = channels[channel]["sockets"][username]
                if client_socket:
                    try:
                        client_socket.sendall(b"[Server Message] You are removed from the channel.\n")
                        stdout.flush()
                    except Exception as e:
                        print(f"[Warning] Failed to notify or shutdown: {e}")
                    finally:
                        print(f"[Server Message] Kicked {username}.")
                        client_socket.close()

        #     # Example: /list channel
        #     if cmd == "/list":
        #         if len(args) != 1:
        #             print("[Usage] /list channel")
        #         elif args[0] not in channels:
        #             print(f"[Server Message] Channel \"{args[0]}\" does not exist.")
        #         else:
        #             users = channels[args[0]]["users"]
        #             print(f"[Server Message] Users in \"{args[0]}\": {', '.join(users)}")

        #     # Add more commands here
        #     else:
        #         # Invalid command keyword
        #         pass

        except Exception as e:
            pass



# CHATGPT
""""
listen_on_ports()
---------------------
Function enables listening to multiple ports at once
REF: This function was generated by ChatGPT
REF: Function was then modified to work with my other functions,
"""

def listen_on_ports(channels):
    failed_ports = []
    successful_sockets = {}
    for channel in channels.values():
        try:
            server_socket = start_server(channel["port"], channel["name"], channel)
            if server_socket:
                successful_sockets[channel["name"]] = server_socket
                
        except Exception:  # Catch bind() failure from start_server
            failed_ports.append(channel["port"])

    if failed_ports: # To print out failed ports first before starting
        for port in failed_ports:
            print(f"Error: unable to listen on port {port}.", file=sys.stderr)
        sys.exit(EXIT_STATUS["PORT"])
    else:
        for channel_name, socket in successful_sockets.items():
            print(f"Channel \"{channel_name}\" is created on port {channels[channel_name]['port']}, with a capacity of " \
                f"{channels[channel_name]['capacity']}.")
            sys.stdout.flush()
            Thread(target=process_connections, args=(socket, channels, channel_name), daemon=True).start()

        # Stdin thread should only run if we didn't exit
        Thread(target=handle_stdin, args=(channels,), daemon=True).start()
        print("Welcome to chatserver.")
        sys.stdout.flush()
        while True:
            pass  # Keep main thread alive 

# Run the server
if __name__ == "__main__":
    afk_time, channels = check_arguments(argv)
    # print("afk_time: ", afk_time)
    # print("channels: ", channels)
    # print(channels.values())
    try:
        listen_on_ports(channels)
    except KeyboardInterrupt:
        print("Server shutting down. BYEEE")
        sys.stdout.flush()


