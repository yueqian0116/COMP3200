from socket import *
from threading import Lock, Thread, current_thread
from time import sleep
from sys import argv,exit
from server_support import *

# Shared resource (counter to count the number of data packets received)
counter = 0
counter_lock = Lock()

BUFSIZE=1024

# if you do the check on the server side and tell the client the result of the check. 
# we have to find a way to keep track of all the usernames in a channel, and make sure it does not exceed the channel capacity
# can use dictionary to keep track of channels and usernames

def handle_client(client_socket, client_address, channels, name):
    global counter
    host,_ = getnameinfo(client_address, 0)
    with client_socket:
        # getting username from client, CHATGPT
        username = client_socket.recv(BUFSIZE).decode().strip()
        print(f"[Server Message] {username} has joined the channel \"{name}\"")
        # Send a message to the client
        # message = f"Welcome to the chatclient, {host}.\n"
        # client_socket.sendall(message.encode())

        while data := client_socket.recv(BUFSIZE):
            # Locking the shared resource (counter)
            with counter_lock:
                print(f"Thread {current_thread().name} got the lock.")
                counter += 1
                print(f"Counter value updated to: {counter}")
                # Simulate doing some work
                sleep(2)
                data = data.decode().upper() 
                client_socket.sendall(data.encode())
        # error or EOF - client disconnected

    print(f"[Server Message] {username} has left the channel.")

def start_server(port, name, channel):
    listening_socket = socket(AF_INET, SOCK_STREAM)
    listening_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
    try:
        listening_socket.bind(('', port))
    except Exception:
        unable_to_listen_port(port)
    listening_socket.listen(5)
    
 
    print(f"Channel \"{channel['name']}\" is created on port {channel['port']}, with a capacity of " \
        f"{channel['capacity']}.")

    return listening_socket

def process_connections(listening_socket, channels, name):
    # is this where you proccess the number of clients u can handle?
    while True:
        client_socket, client_address = listening_socket.accept()
        client_thread = Thread(target=handle_client, 
                args=(client_socket, client_address, channels, name))
        client_thread.start()

# CHATGPT
""""
listen_on_ports()
---------------------
Function enables listening to multiple ports at once
REF: This function was generated by ChatGPT
REF: Function was then modified to work with my other functions
"""

def listen_on_ports(channels):
    for channel in channels.values():
        server_socket = start_server(channel["port"], channel["name"], channel)
        if server_socket: # to listen at multiple ports at once
            Thread(target=process_connections, args=(server_socket, channels, channel["name"]), daemon=True).start()
    print("Welcome to chatserver.")
    sys.stdout.flush()
    while True:
        pass  # Keep main thread alive  

# Run the server
if __name__ == "__main__":
    afk_time, channels = check_arguments(argv)
    # print("afk_time: ", afk_time)
    # print("channels: ", channels)
    # print(channels.values())
    try:
        listen_on_ports(channels)
    except KeyboardInterrupt:
        print("Server shutting down. BYEEE")


    
