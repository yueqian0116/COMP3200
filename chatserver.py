from socket import *
from threading import Lock, Thread, current_thread
from time import sleep
from sys import argv,exit
from server_support import *

# Shared resource (counter to count the number of data packets received)
counter = 0
counter_lock = Lock()

BUFSIZE=1024

# if you do the check on the server side and tell the client the result of the check. 
# we have to find a way to keep track of all the usernames in a channel, and make sure it does not exceed the channel capacity
# can use dictionary to keep track of channels and usernames

def handle_client(client_socket, client_address, channels, name):
    global counter
    host,_ = getnameinfo(client_address, 0)
    with client_socket:
        # getting username from client, CHATGPT
        username = client_socket.recv(BUFSIZE).decode().strip()
        if not capacity_reached(channels, name):
            channels[name]["users"].append(username)
            channels[name]["sockets"][username] = client_socket
           
            message = f"[Server Message] You have joined the channel \"{name}\".\n"
        else:
            channels[name]["queue"].append(username) 
            users_in_front = len(channels[name]["queue"]) - 1 
            message = f"[Server Message] You are in the waiting queue and there are {users_in_front} user(s) ahead of you.\n"
            
            
        print(channels[name])           
        print(f"[Server Message] {username} has joined the channel \"{name}\"")
        # Send a message to the client
        # message = f"Welcome to the chatclient, {host}.\n"
        client_socket.sendall(message.encode())

        try:
            while data := client_socket.recv(BUFSIZE):
                # Locking the shared resource (counter)
                with counter_lock:
                    # print(f"Thread {current_thread().name} got the lock.")
                    counter += 1
                    # print(f"Counter value updated to: {counter}")
                    # Simulate doing some work
                    # sleep(2)
                    data = data.decode().upper() 
                    client_socket.sendall(data.encode())
        except(ConnectionResetError, ConnectionAbortedError, OSError):
            pass

        finally: 
             # cleanup
            if username in channels[name]["users"]:
                channels[name]["users"].remove(username)

            if username in channels[name]["sockets"]:
                channels[name]["sockets"].pop(username)
            # How to notify to all other clients? [Server Message] client_username has left the channel. 
        # error or EOF - client disconnected



def start_server(port, name, channel):
    listening_socket = socket(AF_INET, SOCK_STREAM)
    listening_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
    try:
        listening_socket.bind(('', port))
    except Exception:
        unable_to_listen_port(port)
    listening_socket.listen(5)
    
 
    print(f"Channel \"{channel['name']}\" is created on port {channel['port']}, with a capacity of " \
        f"{channel['capacity']}.")

    return listening_socket

def process_connections(listening_socket, channels, name):
    # is this where you proccess the number of clients u can handle?
    while True:
        client_socket, client_address = listening_socket.accept()
        client_thread = Thread(target=handle_client, 
                args=(client_socket, client_address, channels, name))
        client_thread.start()
       
        


# CHATGPT
""""
handle_stdin()
---------------------
Function enables processing of commands in chatserver's stdin
REF: This function was generated by ChatGPT (to only get the template and How I should start)
REF: Function was then highly modified to work with my other functions,
"""
def handle_stdin(channels):
    while True:
        try:
            line = stdin.readline()
            if not line:
                continue
            line = line.strip()
            if not line.startswith('/'):
                continue

            tokens = line.split()
            if not tokens:
                continue
            
            cmd = tokens[0]
            args = tokens[1:]

            # /kick
            if cmd == "/kick":
                if len(args) != 2:
                    print("Usage: /kick channel_name client_username")
                channel = args[0]
                username = args[1]
                if channel not in channels:
                    print(f"[Server Message] Channel \"{channel}\" does not exist. ")
                elif username not in channels[channel]["users"]:
                    print(f"[Server Message] {username} is not in the channel. ")

                # channel and username exists, Kick user
                client_socket = channels[channel]["sockets"][username]
                if client_socket:
                    try:
                        client_socket.sendall(b"[Server Message] You are removed from the channel.\n")
                        stdout.flush()
                        # client_socket.shutdown(SHUT_RDWR)
                    except Exception as e:
                        print(f"[Warning] Failed to notify or shutdown: {e}")
                    finally:
                        print(f"[Server Message] Kicked {username}.")
                        client_socket.close()




        #     # Example: /list channel
        #     if cmd == "/list":
        #         if len(args) != 1:
        #             print("[Usage] /list channel")
        #         elif args[0] not in channels:
        #             print(f"[Server Message] Channel \"{args[0]}\" does not exist.")
        #         else:
        #             users = channels[args[0]]["users"]
        #             print(f"[Server Message] Users in \"{args[0]}\": {', '.join(users)}")

        #     # Add more commands here
        #     else:
        #         # Invalid command keyword
        #         pass

        except Exception as e:
            print(f"[Error] Failed to handle stdin command: {e}")



# CHATGPT
""""
listen_on_ports()
---------------------
Function enables listening to multiple ports at once
REF: This function was generated by ChatGPT
REF: Function was then modified to work with my other functions,
"""

def listen_on_ports(channels):
    for channel in channels.values():
        server_socket = start_server(channel["port"], channel["name"], channel)
        if server_socket: # to listen at multiple ports at once
            Thread(target=process_connections, args=(server_socket, channels, channel["name"]), daemon=True).start()

    # Stdin Thread should be created when you start the server
    Thread(target=handle_stdin, args=(channels,), daemon=True).start()

    print("Welcome to chatserver.")
    sys.stdout.flush()

    while True:
        pass  # Keep main thread alive  

# Run the server
if __name__ == "__main__":
    afk_time, channels = check_arguments(argv)
    # print("afk_time: ", afk_time)
    # print("channels: ", channels)
    # print(channels.values())
    try:
        listen_on_ports(channels)
    except KeyboardInterrupt:
        print("Server shutting down. BYEEE")


    
