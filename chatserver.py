from socket import *
from threading import Lock, Thread, current_thread
from time import sleep
from sys import argv,exit
from server_support import *

# Shared resource (counter to count the number of data packets received)
counter = 0
counter_lock = Lock()

BUFSIZE=1024

# if you do the check on the server side and tell the client the result of the check. 
# we have to find a way to keep track of all the usernames in a channel, and make sure it does not exceed the channel capacity
# can use dictionary to keep track of channels and usernames

def handle_client(client_socket, client_address, channels, name):
    global counter
    host,_ = getnameinfo(client_address, 0)
    with client_socket:
        username = client_socket.recv(BUFSIZE).decode()
        join_channel(username, channels, name, client_socket)

        try:
            while data := client_socket.recv(BUFSIZE):
                # Locking the shared resource (counter)
                with counter_lock:
                    # print(f"Thread {current_thread().name} got the lock.")
                    counter += 1
                    # print(f"Counter value updated to: {counter}")
                    # Simulate doing some work
                    # sleep(2)
                    message = data.decode()
                    process_message(message, client_socket, channels, username, name)
        except(ConnectionResetError, ConnectionAbortedError, OSError):
            pass

        finally: 
             remove_user_from_users(username, channels, name)
            # How to notify to all other clients? [Server Message] client_username has left the channel. 
        # error or EOF - client disconnected

def start_server(port, name, channel):
    listening_socket = socket(AF_INET, SOCK_STREAM)
    listening_socket.bind(('', port))
    listening_socket.listen(5)

    return listening_socket

def process_connections(listening_socket, channels, name):
    while True:
        client_socket, client_address = listening_socket.accept()
        client_thread = Thread(target=handle_client, 
                args=(client_socket, client_address, channels, name))
        client_thread.start()


# CHATGPT
""""
handle_stdin()
---------------------
Function enables processing of commands in chatserver's stdin
REF: This function was generated by ChatGPT (to only get the template and How I should start)
REF: Function was then highly modified to work with my other functions,
"""
def handle_stdin(channels):
    while True:
        try:
            line = stdin.readline()
            if not line:
                continue
            line = line.rstrip('\n')  # Only remove newline
            if check_for_trailing_spaces(line):
                continue 
            line = line.strip()
            if not line.startswith('/'):
                continue

            tokens = line.split()
            if not tokens:
                continue
            
            cmd = tokens[0]
            args = tokens[1:]

            # /kick
            if cmd == "/kick":
                if len(args) != 2:
                    print("Usage: /kick channel_name client_username")
                    sys.stdout.flush()
                channel = args[0]
                username = args[1]
                if channel not in channels:
                    print(f"[Server Message] Channel \"{channel}\" does not exist.")
                    sys.stdout.flush()
                elif username not in channels[channel]["users"]:
                    print(f"[Server Message] {username} is not in the channel.")
                    sys.stdout.flush()
                # channel and username exists, Kick user
                client_socket = channels[channel]["sockets"][username]
                if client_socket:
                    try:
                        client_socket.sendall(b"[Server Message] You are removed from the channel.\n")
                        sys.stdout.flush()
                    except Exception as e:
                        print(f"[Warning] Failed to notify or shutdown: {e}")
                    finally:
                        print(f"[Server Message] Kicked {username}.")
                        sys.stdout.flush()
                        client_socket.close()
            elif cmd == "/mute":
                if len(args) != 3:
                    print("Usage: /mute channel_name client_username duration")
                    sys.stdout.flush()
                    continue
                channel = args[0]
                client_to_mute = args[2]
                duration = args[3]

                if channel not in channels:
                    print(f"[Server Message] Channel \"{channel}\" does not exist.")
                    sys.stdout.flush()
                elif client_to_mute not in channels[channel]["users"]:
                    print(f"[Server Message] {client_to_mute} is not in the channel.")
                    sys.stdout.flush()
                elif not duration.isdigit() or int(duration) < 0:
                    print("[Server Message] Invalid mute duration.")
                    sys.stdout.flush()
                else: # valid mute command
                    pass
            elif cmd == "/empty":
                if len(args) != 1:
                    print("Usage: /empty channel_name")
                    sys.stdout.flush()
                
                channel = args[0]
                if channel not in channels:
                    print(f"[Server Message] Channel \"{channel}\" does not exist.")
                    sys.stdout.flush()
                else:
                    # remove queue users first
                    msg = "[Server Message] You are removed from the channel.\n"
                    for q_user in channels[channel]["queue"]:
                        q_user_socket = channels[channel]["q_sockets"][q_user]
                        q_user_socket.sendall(msg.encode())
                        q_user_socket.close() # might have issues
                        remove_user_from_queue(q_user, channels, channel)
                    # remove user users
                    for user in channels[channel]["users"]:
                        user_socket = channels[channel]["sockets"][user]
                        user_socket.sendall(msg.encode())
                        user_socket.close()
                        remove_user_from_users(user, channels, channel)
                    print(f"[Server Message] \"{channel}\" has been emptied.")
                    sys.stdout.flush()
            elif cmd == "/shutdown":
                if len(tokens) != 1:
                    print("Usage: /shutdown")
                    sys.stdout.flush()


        except Exception as e:
            print(e)



# CHATGPT
""""
listen_on_ports()
---------------------
Function enables listening to multiple ports at once
REF: This function was generated by ChatGPT
REF: Function was then modified to work with my other functions,
"""
def listen_on_ports(channels):
    failed_ports = []
    successful_sockets = {}
    for channel in channels.values():
        try:
            server_socket = start_server(channel["port"], channel["name"], channel)
            if server_socket:
                successful_sockets[channel["name"]] = server_socket
                
        except Exception:  # Catch bind() failure from start_server
            failed_ports.append(channel["port"])

    if failed_ports: # To print out failed ports first before starting
        for port in failed_ports:
            print(f"Error: unable to listen on port {port}.", file=sys.stderr)
        sys.exit(EXIT_STATUS["PORT"])
    else:
        for channel_name, socket in successful_sockets.items():
            print(f"Channel \"{channel_name}\" is created on port {channels[channel_name]['port']}, with a capacity of " \
                f"{channels[channel_name]['capacity']}.")
            sys.stdout.flush()
            Thread(target=process_connections, args=(socket, channels, channel_name), daemon=True).start()

        # Stdin thread should only run if we didn't exit
        Thread(target=handle_stdin, args=(channels,), daemon=True).start()
        print("Welcome to chatserver.")
        sys.stdout.flush()
        while True:
            pass  # Keep main thread alive 

# Run the server
if __name__ == "__main__":
    afk_time, channels = check_arguments(argv)
    try:
        listen_on_ports(channels)
    except KeyboardInterrupt:
        print("[Server Message] Server shuts down.")
        sys.stdout.flush()

